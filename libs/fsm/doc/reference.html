<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE>The Boost FSM Library Reference</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0.2  (Win32)">
	<META NAME="CREATED" CONTENT="20061203;16314615">
	<META NAME="CHANGEDBY" CONTENT="Andrey Semashev">
	<META NAME="CHANGED" CONTENT="20061210;3203271">
	<STYLE>
		pre{
			BORDER-RIGHT: gray 1pt solid;
			PADDING-RIGHT: 2pt;
			BORDER-TOP: gray 1pt solid;
			DISPLAY: block;
			PADDING-LEFT: 2pt;
			PADDING-BOTTOM: 2pt;
			BORDER-LEFT: gray 1pt solid;
			MARGIN-RIGHT: 32pt;
			PADDING-TOP: 2pt;
			BORDER-BOTTOM: gray 1pt solid;
			FONT-FAMILY: "Courier New", Courier, mono;
			background-color: #EEEEEE;
		}
		.keyword{color: #0000FF;}
		.comment{font-style: italic; color: #008000;}
	</STYLE>
</HEAD>
<BODY LANG="ru-RU" TEXT="#000000" BGCOLOR="#ffffff" DIR="LTR" link="#0000FF" vlink="#840084" alink="#0000FF">
<P><IMG SRC="../../../boost.png" NAME="Boost logo" ALT="C++ Boost" ALIGN=BOTTOM WIDTH=277 HEIGHT=86 BORDER=0>
</P>
<P>
<OL>
	<LI><A HREF="#Concepts">Concepts</A></LI>
	<OL>
		<LI><A HREF="#States">States</A></LI>
		<LI><A HREF="#Events">Events</A></LI>
		<LI><A HREF="#Event handlers">Event handlers</A></LI>
		<LI><A HREF="#Transitions">Transitions</A></LI>
		<LI><A HREF="#Enter and leave state handlers, reset handler">Enter and leave state handlers, reset handler</A></LI>
		<LI><A HREF="#Unexpected event handlers">Unexpected event handlers</A></LI>
		<LI><A HREF="#State name accessors">State name accessors</A></LI>
		<LI><A HREF="#State machine return types">State machine return types</A></LI>
	</OL>
	<LI><A HREF="#Reference">Reference</A></LI>
	<OL>
		<LI><A HREF="#Type state_id_t">Type <CODE>state_id_t</CODE></A></LI>
		<LI><A HREF="#Class template state">Class template <CODE>state</CODE></A></LI>
		<LI><A HREF="#Class template state_machine">Class template <CODE>state_machine</CODE></A></LI>
		<LI><A HREF="#Class template locking_state_machine">Class template <CODE>locking_state_machine</CODE></A></LI>
		<LI><A HREF="#Class template basic_transition">Class template <CODE>basic_transition</CODE></A></LI>
		<LI><A HREF="#Class template transition">Class template <CODE>transition</CODE></A></LI>
		<LI><A HREF="#Class templates event and event_c">Class templates <CODE>event</CODE> and <CODE>event_c</CODE></A></LI>
		<LI><A HREF="#Class fsm_error">Class <CODE>fsm_error</CODE></A></LI>
		<LI><A HREF="#Class bad_state_id">Class <CODE>bad_state_id</CODE></A></LI>
		<LI><A HREF="#Class unexpected_event">Class <CODE>unexpected_event</CODE></A></LI>
	</OL>
</OL>
<A HREF="state_machine.html">Back to the main page</A>
</P>
<P><BR><BR>
</P>
<H2><A NAME="Concepts">Concepts</A></H2>
<P>
In this section requirements to user-defined types and handlers are described. The library tries to check in compile time
whether these requirements are met, so in many cases an incorrect code will simply not compile. But still it is possible
to compile an invalid code and the error will be seen only in run time. Therefore reading this section is highly recommended.
</P>
<H3><A NAME="States">States</A></H3>
<P>
<ul>
	<li>Each state should publicly and unambguously inherit from a single
	<A HREF="#Class template state"><code>fsm::state</code></A> class template instance. A state may
	inherit other classes in any way, such inheritance is not noticed by the library. It is guaranteed that
	if several states of a single state machine virtually inherit the same base class then this virtual
	base class is shared between the states (i.e. the state machine object will contain only one instance
	of the virtual base class).</li>
	<li>Each state in a complete state machine should have its own distinct type, so there
	will be only one instance of the state object in the state machine object.</li>
	<li>All states of a complete state machine and the machine itself should be using exactly the same
	states type sequences and return types.</li>
	<li>A state may be used to define several state machines. Although, these state machines
	should have the same set of states and refurn types, as follows from the <A HREF="#Class template state"><code>fsm::state</code></A>
	class template definition.</li>
	<li>A state should have public default constructor and destructor, both of which may be generated by the compiler.
	State's destructor must not throw.</li>
	<li>A state should be copy-constructible if the complete state machine is intended to be copy-constructible.</li>
	<li>A state should be assignable if the complete state machine is intended to be assignable.</li>
	<li>All user-defined state members used by the library should be public. This includes, but not limited to,
	event handlers, state entry and exit handlers, state-specific transitions map.</li>
	<li>A user should not try to construct in any way a standalone state object, outside of the complete state machine.</li>
	<li>A user should not try to gain access from one state to another. If some data or methods should be shared
	between states, it must be extracted into a virtual base class.</li>
</ul>
</P>

<H3><A NAME="Events">Events</A></H3>
<P>
<ul>
	<li>The library supports events of any type including fundamental types, except <code>void</code>.</li>
	<li>The library handles any events by constant reference which means that <code>const</code> qualifier and
	a reference may be added to the event type before passing to an event handler. Generally, users should not
	differentiate event types only by cv-qualifiers and referenceness.</li>
	<li>An event should be destructible. Event destructors should not throw.</li>
	<li>An event should be copy-constructible.</li>
	<li>The library only differentiates events by their static type, the dynamic type of events is not taken into account.
	In particular this means that a polymotphic event passed by reference to its base class may be copied
	only partially with all the derived dynamic part cut off (this may be done on exception throwing, for example).
	In conjunction with &quot;copy-constructible&quot; requirement this means that static type of event
	should not be abstract. If otherwise needed, a pointer to abstract base class of the event should be passed
	instead of reference.</li>
</ul>
It must be noted that state machine implementation may add other requirements to event types.
</P>

<H3><A NAME="Event handlers">Event handlers</A></H3>
<P>
<ul>
	<li>A state may have zero or more event handlers. Each event handler is a non-static member function named
	<code>on_process</code> taking a single mandatory argument (an event) and returning a value implicitly convertible to
	the state machine return value (or <code>void</code> if the machine returns nothing). An event handler may
	be template if all template parameters are deducable from its argument.</li>
	<li>All events delivered to the event handlers are passed by constant reference. Upon event delivery to a
	corresponding event handler only standard event type conversions (see 13.3.3.1.1, [over.ics.scs]) are allowed
	for the event to be delivered. If a user-defined conversion (see 12.3, [class.conv]) is to be involved, then
	the event delivery code will most probably not compile. In case of ellipsis conversion (see 13.3.3.1.3, [over.ics.ellipsis])
	or no conversion found to pass the event to a handler the event is considered to be unexpected and handled
	appropriately. It must be admitted though that some compilers might erroneously prefer ellipsis-version event handler
	over an unexpected event handler. Since proper compilers will never call such handler, it is not a good idea to define
	event handler with an ellipsis in the first place.</li>
	<li>An event handler may throw an exception which will be propagated to the state machine caller without any change.</li>
</ul>
</P>

<H3><A NAME="Transitions">Transitions</A></H3>
<P>
<ul>
	<li>A transition rule is a class that has at least two public members:<br>
	<code>template&lt; typename StateT, typename EventT &gt; struct is_applicable;</code><br>
	<code>void transit(<i>state type</i>&amp; state, <i>event type</i> const&amp; evt);</code><br>
	<li>A class template predicate <code>is_applicable</code>
	should have a static boolean constant <code>value</code>
	that equals <code>true</code> if this element of transitions map may be used to
	perform the transition or <code>false</code> otherwise. The predicate takes
	two template parameters: the current state (<code>StateT</code>) type and the event type
	(<code>EventT</code>).<br>
	This template is instantiated for each state in the state machine and each
	event type being ever processed by it in all combinations. This makes
	a suitability matrix for the given transition map element. And since there may be
	more than one elements in the map, these elements are looked in forward direction
	until the library finds an element that returns <code>true</code> from the
	predicate. If it finds one, it stops the search and uses this element as a
	transition rule.</li>
	<li>A static function <code>transit</code> should take a reference to the current state
	and an event as arguments. This function should perform all needed actions to switch to
	target state (call to the <code>switch_to</code> method in the current state in the simpliest
	case). It must be noted that this function may perform no transition in which case the event
	will be passed into the current state.<br>
	There may be more than one such overloaded functions, including templates. This
	function is called by the library if the <code>is_applicable</code>
	predicate of the element returned <code>true</code>. If the function throws, the
	exception is propagated to the FSM's caller.</li>
	<li>A transition object is never created by the library, there are no requirements on constructors, destructor
	or assignment operators.</li>
</ul>
</P>

<H3><A NAME="Enter and leave state handlers, reset handler">Enter and leave state handlers, reset handler</A></H3>
<P>
<ul>
	<li>A state may have at most one entering handler. Such handler should be a non-static member function with the following
	signature:<br>
	<code>void on_enter_state();</code></li>
	<li>A state may have at most one leaving handler. Such handler should be a non-static member function with the following
	signature:<br>
	<code>void on_leave_state();</code></li>
	<li>Entering and leaving state handlers may throw exceptions. In this case the exception will be propagated to the caller.
	If called from the <code>switch_to</code> method, no transition is made.</li>
	<li>A state may have at most one reset handler. Such handler should be a non-static member function with the following
	signature:<br>
	<code>void on_reset();</code></li>
	<li>Reset handlers may throw exceptions, though this will have no effect and the exception will be ignored.</li>
	<li>Neither of these three handlers should try change the state of the state machine (i.e. call to <code>switch_to</code>)
	during execution. It is not specified which state is current while executing these handlers.</li>
</ul>
</P>

<H3><A NAME="Unexpected event handlers">Unexpected event handlers</A></H3>
<P>
<ul>
	<li>Unexpected event handler is either a pointer to function or a function object that supports the following signature:<br>
	<code>return_type (any const&amp;, std::type_info const&amp;, fsm::state_id_t);</code><br>
	See <a href="state_machine.html#Unexpected events handling">this section</a> for more details.</li>
	<li>Unexpected event handlers should be copy-constructible and destructible.</li>
	<li>Unexpected event handlers may throw. In this case the exception will be propagated to the state machine caller.</li>
</ul>
</P>

<H3><A NAME="State name accessors">State name accessors</A></H3>
<P>
<ul>
	<li>A state may have at most one state name accessor. Such accessor should be a static member function with the following
	signature:<br>
	<code>static std::string const&amp; get_state_name();</code></li>
	<li>Unlike other handlers, the state name accessor is not thread-protected by the
	<A HREF="#Class template locking_state_machine"><code>locking_state_machine</code></A> class template. User should provide
	synchronization to safely construct the state name, if needed.</li>
	<li>The accessor may throw exceptions, though users are highly discouraged from doing this since the method is
	used in construction of the library-provided exceptions. Exceptions thrown will be propagated to the caller.</li>
</ul>
</P>

<H3><A NAME="State machine return types">State machine return types</A></H3>
<P>
<ul>
	<li>A state machine return type may be any type that is valid as a function return type and allowed to participate in a
	return statement (6.6.3, [stmt.return]).</li>
</ul>
</P>

<P><BR><BR>
</P>

<H2><A NAME="Reference">Reference</A></H2>
<H3><A NAME="Type state_id_t">Type <CODE>state_id_t</CODE></A></H3>
<P>
The <CODE>state_id_t</CODE> type is used by the library to identify states within a complete state machine. This type
is defined in <code>exceptions.hpp</code> file in <code>boost::fsm</code> namespace. The type gives following guaranties:
<ul>
	<li>The type is default and copy-constructible, destructible and assignable</li>
	<li>The type is comparable for equality and inequality</li>
	<li>No operations mentioned above throw exceptions</li>
</ul>
</P>

<P><BR></P>

<H3><A NAME="Class template state">Class template <CODE>state</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt; <span class=keyword>typename</span> StateT, <span class=keyword>typename</span> StateListT, <span class=keyword>typename</span> RetValT = <span class=keyword>void</span> &gt;
<span class=keyword>class</span> state
{
<span class=keyword>public</span>:
  <span class=comment>// Types</span>
  <span class=keyword>typedef</span> RetValT return_type;

  <span class=comment>// Constants</span>
  <span class=keyword>static const unsigned int</span> states_count = <I>number of states in StateListT sequence</I>;
  <span class=keyword>static const</span> state_id_t state_id = <I>implementation defined identifier</I>;

  <span class=comment>// Public methods</span>
  state_id_t get_current_state_id() <span class=keyword>const</span>;

  std::type_info <span class=keyword>const</span>&amp; get_current_state_type() <span class=keyword>const</span>;
  std::type_info <span class=keyword>const</span>&amp; get_state_type(state_id_t state_id) <span class=keyword>const</span>;

  std::string <span class=keyword>const</span>&amp; get_current_state_name() <span class=keyword>const</span>;
  std::string <span class=keyword>const</span>&amp; get_state_name(state_id_t state_id) <span class=keyword>const</span>;

  <span class=keyword>void</span> on_enter_state();
  <span class=keyword>void</span> on_leave_state();
  <span class=keyword>void</span> on_reset();

  <span class=keyword>static</span> std::string <span class=keyword>const</span>&amp; get_state_name();

<span class=keyword>protected</span>:
  <span class=comment>// Protected methods (available from state implementation)</span>
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> AnotherStateT &gt;
  <span class=keyword>void</span> switch_to();
  <span class=keyword>void</span> switch_to(state_id_t next_state_id);
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/state_machine.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types</a></h4>

<P>
<ul>
  <li><code>StateT</code>. A final state type that publicly inherits this <code>state</code> instantiation.
    The final state class may have other base classes even between it and the <code>state</code> instantiation.
    The StateT class must be in the StateListT type sequence.
  </li>
  <li><code>StateListT</code>. An MPL type sequence that enlists all states the state machine consists of.</li>
  <li><code>RetValT</code>. A return type of the state machine. Every <code>on_process</code> event handler must
    return a value convertible to this type.
  </li>
</ul>
</P>

<h4><a name="types">Types</a></h4>

<P>
The <code>state</code> class template only provides <code>return_type</code> type that reflects the <code>RetValT</code> template parameter.
</P>

<h4><a name="constants">Constants</a></h4>

<p>
	<ul>
		<li><code>states_count</code>. The static constant equals to number of states in the <code>StateListT</code> template parameter.</li>
		<li><code>state_id</code>. A unique in scope of a complete state machine identifier that may be used to identify the state.</li>
	</ul>
</p>

<h4><a name="constructors">Constructors, copy and assignment</a></h4>

<P>
As seen in synopsis, constructors and assignment operator are trivial.
</P>

<h4><a name="accessors">Accessors</a></h4>

<code>state_id_t get_current_state_id() const;</code>

<blockquote>
<b>Returns:</b> The return value is an identifier of state in which the state machine persists at the point of call.
In most cases this call merely returns the identifier of the state from which the call is made. But this accessor
may make sense if being called after calling to a <code>switch_to</code> modifier.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>std::type_info const&amp; get_current_state_type() const;</code>

<blockquote>
<b>Returns:</b> Equivalent to <code>get_state_type(get_current_state_id());</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>std::type_info const&amp; get_state_type(state_id_t state_id) const;</code>

<blockquote>
<b>Returns:</b> Type information for the final state type identified with <code>state_id</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Throws <code>bad_state_id</code> if <code>state_id</code> is not valid.<br>
</blockquote><br>

<code>std::string const&amp; get_current_state_name() const;</code>

<blockquote>
<b>Returns:</b> Equivalent to <code>get_state_name(get_current_state_id());</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>std::string const&amp; get_state_name(state_id_t state_id) const;</code>

<blockquote>
<b>Returns:</b> The result of the static member function <code>get_state_name</code> for the final state type
identified with <code>state_id</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Throws <code>bad_state_id</code> if <code>state_id</code> is not valid. Additionally, throws anything that the
static member function <code>get_state_name</code> may throw.<br>
</blockquote><br>

<code>static std::string const&amp; get_state_name();</code>

<blockquote>
<b>Returns:</b> The returned value is a reference to a default library-generated name of the final state. The library will try to do its best
to make this name human readable.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="modifiers">Modifiers</a></h4>

<code>void on_enter_state();</code>

<blockquote>
<b>Effects:</b> None. This empty empty handler is only used to provide optionality of the same-named handler in the final state class.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<code>void on_leave_state();</code>

<blockquote>
<b>Effects:</b> None. This empty empty handler is only used to provide optionality of the same-named handler in the final state class.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<code>void on_reset();</code>

<blockquote>
<b>Effects:</b> None. This empty empty handler is only used to provide optionality of the same-named handler in the final state class.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<code>template&lt; typename AnotherStateT &gt; void switch_to();</code>

<blockquote>
<b>Effects:</b> Calls to <code>on_leave_state</code> in the current state, then calls to <code>on_enter_state</code> in the <code>AnotherStateT</code>,
then changes current state to <code>AnotherStateT</code> and returns. The <code>AnotherStateT</code> must be in the <code>StateListT</code> type
sequence.<br>
<b>Complexity:</b> <code>O(1)</code>, not including the complexity of user-provided <code>on_enter_state</code> or <code>on_leave_state</code>.<br>
<b>Exception safety:</b> Does not throw, unless <code>on_enter_state</code> or <code>on_leave_state</code> throws. If it does the current state
remains the same.<br>
</blockquote>

<code>void switch_to(state_id_t next_state_id);</code>

<blockquote>
<b>Effects:</b> Calls to <code>on_leave_state</code> in the current state, then calls to <code>on_enter_state</code> in the target state identified
with <code>next_state_id</code>, then changes current state to the target state and returns.<br>
<b>Complexity:</b> <code>O(1)</code>, not including the complexity of user-provided <code>on_enter_state</code> or <code>on_leave_state</code>.<br>
<b>Exception safety:</b> Throws <code>bad_state_id</code> if the <code>next_state_id</code> is not valid. If either <code>on_enter_state</code> or <code>on_leave_state</code> throws the current state remains the same.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class template state_machine">Class template <CODE>state_machine</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt; <span class=keyword>typename</span> StateListT, <span class=keyword>typename</span> RetValT = <span class=keyword>void</span>, <span class=keyword>typename</span> TransitionListT = <span class=keyword>void</span> &gt;
<span class=keyword>class</span> state_machine
{
<span class=keyword>public</span>:
  <span class=comment>// Types</span>
  <span class=keyword>typedef</span> StateListT states_type_list;
  <span class=keyword>typedef</span> RetValT return_type;
  <span class=keyword>typedef</span> <I>implementation defined MPL type sequence</I> transitions_type_list;

  <span class=comment>// Constants</span>
  <span class=keyword>static const unsigned int</span> states_count = <I>number of states in StateListT sequence</I>;

  <span class=comment>// Constructors</span>
  state_machine();
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> T &gt;
  state_machine(T <span class=keyword>const</span>&amp; handler);

  <span class=comment>// Public methods</span>
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> StateT &gt;
  <span class=keyword>bool</span> is_in_state() <span class=keyword>const</span>;

  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> T &gt;
  T&amp; get();
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> T &gt;
  T <span class=keyword>const</span>&amp; get() <span class=keyword>const</span>;

  state_id_t get_current_state_id() <span class=keyword>const</span>;

  std::type_info <span class=keyword>const</span>&amp; get_current_state_type() <span class=keyword>const</span>;
  std::type_info <span class=keyword>const</span>&amp; get_state_type(state_id_t state_id) <span class=keyword>const</span>;

  std::string <span class=keyword>const</span>&amp; get_current_state_name() <span class=keyword>const</span>;
  std::string <span class=keyword>const</span>&amp; get_state_name(state_id_t state_id) <span class=keyword>const</span>;

  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> EventT &gt;
  return_type process(EventT <span class=keyword>const</span>&amp; evt);

  <span class=keyword>void</span> reset();

  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> T &gt;
  <span class=keyword>void</span> set_unexpected_event_handler(T <span class=keyword>const</span>&amp; handler);
  <span class=keyword>void</span> set_default_unexpected_event_handler();
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/state_machine.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types</a></h4>

<P>
<ul>
  <li><code>StateListT</code>. An MPL type sequence that enlists all states the state machine consists of.</li>
  <li><code>RetValT</code>. A return type of the state machine.</li>
  <li><code>TransitionListT</code>. An MPL type sequence that enlists all automatic transition rules.</li>
</ul>
</P>

<h4><a name="types">Types</a></h4>

<p>
	<ul>
		<li><code>states_type_list</code>. This type reflects <code>StateListT</code> template parameter.</li>
		<li><code>return_type</code>. This type reflects <code>RetValT</code> template parameter.</li>
		<li><code>transitions_type_list</code>. The same as <code>TransitionListT</code> template parameter if it is specified.
			Otherwise the type is an empty MPL type sequence.
		</li>
	</ul>
</p>

<h4><a name="constants">Constants</a></h4>

<p>
The <code>state_machine</code> class template defines only the <code>states_count</code> static constant that equals to the number of states
in the <code>StateListT</code> template parameter.
</p>

<h4><a name="constructors">Constructors, copy and assignment</a></h4>

<code>state_machine();</code>

<blockquote>
<b>Effects:</b> Default constructs the state machine. The current state right after construction is the first state in the <code>StateListT</code>
type sequence.<br>
<b>Complexity:</b> <code>O(states_count)</code> for the first object construction, <code>O(1)</code> for the
consequent objects construction, not including the complexity of states construction.<br>
<b>Exception safety:</b> Does not throw, unless a state constructor throws.<br>
</blockquote><br>

<code>template&lt; typename T &gt; state_machine(T const&amp; handler);</code>

<blockquote>
<b>Effects:</b> Equivalent to default-constructing <code>state_machine</code> object and immediately calling <code>set_unexpected_event_handler(handler)</code> on it.<br>
<b>Complexity:</b> <code>O(states_count)</code> for the first object construction, <code>O(1)</code> for the
consequent objects construction, not including the complexity of states construction.<br>
<b>Exception safety:</b> Does not throw, unless a state constructor or <code>set_unexpected_event_handler</code> throws.<br>
</blockquote>

<h4><a name="accessors">Accessors</a></h4>

<code>template&lt; typename StateT &gt; bool is_in_state() const;</code>

<blockquote>
<b>Returns:</b> Equivalent to <code>get_current_state_id() == StateT::state_id</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>template&lt; typename T &gt; T&amp; get();</code><br>
<code>template&lt; typename T &gt; T const&amp; get() const;</code>

<blockquote>
<b>Returns:</b> A (constant) reference to state or states' public base class <code>T</code>. If <code>T</code> is the public base class of more than
one state then it must be a virtual base to disambiguate the instance to return reference to.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>state_id_t get_current_state_id() const;</code><br>
<code>std::type_info const&amp; get_current_state_type() const;</code><br>
<code>std::type_info const&amp; get_state_type(state_id_t state_id) const;</code><br>
<code>std::string const&amp; get_current_state_name() const;</code><br>
<code>std::string const&amp; get_state_name(state_id_t state_id) const;</code>

<blockquote>
See the description of these methods in the <A HREF="#Class template state"><code>state</code> class template</A> reference.
</blockquote>

<h4><a name="modifiers">Modifiers</a></h4>

<code>template&lt; typename EventT &gt; return_type process(EventT const&amp; evt);</code>

<blockquote>
<b>Effects:</b> First performs a lookup in the automatic transitions map for a transition rule (see synopsis of the
<a href="#Class template transition"><code>transition</code> class template</a> to see the required members of a transition rule).
If the rule is found its static member function <code>is_allowed</code> is called with <code>evt</code> to check weither the transition
is allowed to take place. If the result is positive the transition to the target state (equivalent to call to
<code>switch_to&lt; <i>target state</i> &gt;()</code> in the current state).<br>
After that a call to <code>on_process</code> in the target (current, if no transition took place) state is made. The <code>evt</code> object
is passed as a single argument of the <code>on_process</code> handler.<br>
If no appropriate <code>on_process</code> handler found to take <code>evt</code> as an argument the unexpected event handler is invoked.<br>
<b>Returns:</b> The result of the <code>on_process</code> handler or unexpected event handler call, whichever occured.<br>
<b>Complexity:</b> <code>O(states_count)</code> for the first call for each distinctive type <code>EventT</code>, <code>O(1)</code> for
the consequent calls on this or any other instances of the state machine. The estimations are made not including the complexity of any user-defined
handlers involved during the call.<br>
<b>Exception safety:</b> Does not throw, unless a user-defined handler throws.<br>
</blockquote><br>

<code>void reset();</code>

<blockquote>
<b>Effects:</b> Calls to <code>on_reset</code> handlers in every state. Then silently (with no handlers called) resets to the initial state.<br>
<b>Complexity:</b> <code>O(1)</code>, not including the complexity of <code>on_reset</code> handlers.<br>
<b>Exception safety:</b> Does not throw. Any exceptions thrown from the <code>on_reset</code> handlers are suppressed.<br>
</blockquote><br>

<code>template&lt; typename T &gt; void set_unexpected_event_handler(T const&amp; handler);</code>

<blockquote>
<b>Effects:</b> Sets a function object or a function pointer <code>handler</code> as an unexpected events processing routine. If by
the time of the call there already was set an unexpected events handler the old handler is lost.<br>
This routine will be called each time when the library discovers that an event <code>e</code> of given type <code>E</code>
cannot be processed in the current state <code>S</code> because there is no <code>on_process</code> handler method in the
state that could accept the event. Therefore <code>handler</code> must provide <code>operator()</code> with the following signature
(in case if <code>handler</code> is a function pointer this must be the function's signature):<br>
<pre>return_type (boost::any <span class=keyword>const</span>&amp; evt, std::type_info <span class=keyword>const</span>&amp; state_type, state_id_t state_id);</pre>
While being called <code>handler</code>'s arguments will be filled as follows: <code>evt</code> will contain <code>e</code>,
<code>state_type</code> will contain <code>typeid(S)</code>, <code>state_id</code> will contain <code>S::state_id</code>. The return
value of <code>handler</code>, if it returns normally, will be returned from <code>process</code> method of the state machine.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> May throw if <code>boost::function</code> assignment operator throws. This may be <code>std::bad_alloc</code>
in case of insufficient memory.<br>
</blockquote><br>

<code>void set_default_unexpected_event_handler();</code>

<blockquote>
<b>Effects:</b> Restores the default library behaviour on unexpected events - throwing an <code>unexpected_event</code> exception.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class template locking_state_machine">Class template <CODE>locking_state_machine</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt;
  <span class=keyword>typename</span> StateListT,
  <span class=keyword>typename</span> RetValT = <span class=keyword>void</span>,
  <span class=keyword>typename</span> TransitionListT = <span class=keyword>void</span>,
  <span class=keyword>typename</span> MutexT = <I>unspecified</I>,
  <span class=keyword>typename</span> LockerT = <span class=keyword>typename</span> MutexT::scoped_lock
&gt;
<span class=keyword>class</span> locking_state_machine :
  <span class=keyword>public</span> state_machine&lt; StateListT, RetValT, TransitionListT &gt;
{
<span class=keyword>public</span>:
  <span class=comment>// Inherits all members from the base class</span>

  <span class=comment>// Types</span>
  <span class=keyword>typedef</span> MutexT mutex_type;
  <span class=keyword>typedef</span> LockerT scoped_lock;

  <span class=comment>// Public methods</span>
  mutex_type&amp; get_mutex() <span class=keyword>const</span>;
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/locking_state_machine.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types</a></h4>

<P>
<code>StateListT</code>, <code>RetValT</code> and <code>TransitionListT</code> types have the same semantics
as for the <A HREF="#Class template state_machine"><code>state_machine</code> class template</A>.
<ul>
  <li><code>MutexT</code>. A mutex type to be used to lock the state machine object. The default mutex type
  is a recursive mutex on platforms that support multithreading (currently, pthreads and WinAPI
  threading APIs are supported by default). A <a href="../../thread/index.html">Boost.Thread</a> mutex model
  may be used in this type.</li>
  <li><code>LockerT</code>. A scoped locker type used to lock and unlock the mutex. With given object <code>m</code>
  of type <code>MutexT</code> the expression <code>LockerT l(m);</code> should be valid and result in locking <code>m</code>
  until destruction of <code>l</code>. By default a scoped waiting locker is used (in other words, it puts the thread
  into sleep if the mutex is already locked by another thread).
  A <a href="../../thread/index.html">Boost.Thread</a> scoped lock model may be used in this type.</li>
</ul>
</P>

<h4><a name="accessors">Accessors</a></h4>

<code>mutex_type&amp; get_mutex() const;</code>

<blockquote>
<b>Returns:</b> A reference to mutex object used to synchronize threads.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="thread_safety">Thread safety</a></h4>

<P>
As you may see the <code>locking_state_machine</code> class template provides almost the same interface as
<A HREF="#Class template state_machine"><code>state_machine</code></A> does. These methods of the interface
also provide automatic mutex locking:
<ul>
	<li>Copy constructor. Locks the argument of the constructor until constrution is finished.</li>
	<li>Assignment operator. Locks both the argument and the object being assigned to until the assignment is finished.</li>
	<li><code>template&lt; typename EventT &gt; return_type process(EventT const&amp; evt);</code>. Locks for the whole event processing.</li>
	<li><code>void reset();</code>. Locks for the whole reset process.</li>
	<li><code>template&lt; typename T &gt; void set_unexpected_event_handler(T const&amp; handler);</code>. Locks to make <code>handler</code> copying thread-safe.</li>
	<li><code>void set_default_unexpected_event_handler();</code>. Locks to make previous handler destruction thread-safe.</li>
</ul>
All other methods are left lock-free. That being said, the following guarantees may be given to users' code:
<ul>
	<li>States' copying and assignment is performed in one thread concurrently.</li>
	<li>The <code>on_process</code>, <code>on_reset</code>, <code>on_enter_state</code> and <code>on_leave_state</code> state handlers are executed in one thread concurrently.</li>
	<li>The <code>transit</code> static members of transitions are executed in one thread concurrently.</li>
	<li>The unexpected events handler set by <code>set_unexpected_event_handler</code> is executed in one thread concurrently.</li>
</ul>
A user should remember that <code>get_state_name</code> static member function of the state is left unlocked. If he or she overrides the default
implementation of <code>get_state_name</code> in the <code>fsm::state</code> class, the user might want to put additional effort to make his or her
implementation thread-safe.
</P>

<P><BR></P>

<H3><A NAME="Class template basic_transition">Class template <CODE>basic_transition</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt; <span class=keyword>typename</span> NextStateT &gt;
<span class=keyword>struct</span> basic_transition
{
  <span class=comment>// Public methods</span>
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> CurrentStateT, <span class=keyword>typename</span> EventT &gt;
  <span class=keyword>static void</span> transit(CurrentStateT&amp; state, EventT <span class=keyword>const</span>&amp; evt);
};</PRE></blockquote>
</P>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/transition.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types and values</a></h4>

The <code>NextStateT</code> type is a final state type to perform transition to if all transition rule checks pass.

<h4><a name="constructors">Constructors, copy and assignment</a></h4>

<P>
Since no objects of transition rules are to be created no specific constructors or operators are provided.
</P>

<h4><a name="modifiers">Modifiers</a></h4>

<code>template&lt; typename CurrentStateT, typename EventT &gt; static void transit(CurrentStateT&amp; state, EventT const&amp; evt);</code>

<blockquote>
<b>Effects:</b> Equivalent to <code>state.switch_to&lt; NextStateT &gt;()</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw unless any user handlers throw.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class template transition">Class template <CODE>transition</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt; <span class=keyword>typename</span> CurrentStateT, <span class=keyword>typename</span> EventT, <span class=keyword>typename</span> NextStateT &gt;
<span class=keyword>struct</span> transition :
  <span class=keyword>public</span> basic_transition&lt; NextStateT &gt;
{
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> StateT, <span class=keyword>typename</span> EvtT &gt;
  <span class=keyword>struct</span> is_applicable;
};</PRE></blockquote>
</P>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/transition.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types</a></h4>

<P>
<ul>
  <li><code>CurrentStateT</code>. A final state type in which state machine must persist the transition to take place. This
  template parameter may also be <code>any_state</code> to indicate that the transition rule is actual in all states.</li>
  <li><code>EventT</code>. An event type that triggers the transition.</li>
  <li><code>NextStateT</code>. A final state type to perform transition to if all transition rule checks pass.</li>
</ul>
</P>

<h4><a name="types">Types</a></h4>

<code>template&lt; typename StateT, typename EvtT &gt; struct is_applicable;</code>

<blockquote>
This class template is an MPL-style predicate that has static member boolean constant <code>value</code>. The constant equals <code>true</code>
if both these conditions are met:
<ul>
	<li><code>StateT</code> equals to <code>CurrentStateT</code> or <code>CurrentStateT</code> equals to <code>any_state</code></li>
	<li><code>EvtT</code> equals to <code>EventT</code></li>
</ul>
Otherwise the <code>value</code> constant equals to <code>false</code>.
</blockquote>

<h4><a name="constructors">Constructors, copy and assignment</a></h4>

<P>
Since no objects of transition rules are to be created no specific constructors or operators are provided.
</P>

<P><BR></P>

<H3><A NAME="Class templates event and event_c">Class templates <CODE>event</CODE> and <CODE>event_c</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>template</span>&lt; <span class=keyword>typename</span> TagT, <span class=keyword>typename</span> T0 = <span class=keyword>void</span>, <I>...</I>, <span class=keyword>typename</span> T<I>n</I> = <span class=keyword>void</span> &gt;
<span class=keyword>struct</span> event :
  <span class=keyword>public</span> tuple&lt; <I>significant types from T0 to Tn</I> &gt;
{
  <span class=comment>// Types</span>
  <span class=keyword>typedef</span> TagT tag_type;
  <span class=keyword>typedef</span> tuple&lt; <I>significant types from T0 to Tn</I> &gt; tuple_type;

  <span class=comment>// Constructors</span>
  event();
  <span class=keyword>explicit</span> event(tuple_type <span class=keyword>const</span>&amp; that);

  <span class=comment>// Assignment</span>
  event&amp; operator= (event <span class=keyword>const</span>&amp; that);
  <span class=keyword>template</span>&lt; <span class=keyword>typename</span> U &gt;
  event&amp; operator= (U <span class=keyword>const</span>&amp; that);

  <span class=comment>// Public methods</span>
  tuple_type&amp; get_tuple();
  tuple_type <span class=keyword>const</span>&amp; get_tuple() <span class=keyword>const</span>;
};

<span class=keyword>template</span>&lt; <span class=keyword>int</span> TagV, <span class=keyword>typename</span> T0 = <span class=keyword>void</span>, <I>...</I>, <span class=keyword>typename</span> T<I>n</I> = <span class=keyword>void</span> &gt;
<span class=keyword>struct</span> event_c :
  <span class=keyword>public</span> event&lt; mpl::int_&lt; TagV &gt;, T0, <I>...</I>, T<I>n</I> &gt;
{
  <span class=comment>// Inherits all members from the base class</span>
};

<span class=comment>// Helper construction functions</span>
<span class=keyword>template</span>&lt; <span class=keyword>typename</span> TagT, <span class=keyword>typename</span> ArgT0, <I>...</I>, <span class=keyword>typename</span> ArgT<I>m</I> &gt;
event&lt; TagT, <I>adopted ArgT0 - ArgTm types</I> &gt; make_event(ArgT0 <span class=keyword>const</span>&amp; arg0, <I>...</I>, ArgT<I>m</I> <span class=keyword>const</span>&amp; arg<I>m</I>);

<span class=keyword>template</span>&lt; <span class=keyword>int</span> TagV, <span class=keyword>typename</span> ArgT0, <I>...</I>, <span class=keyword>typename</span> ArgT<I>m</I> &gt;
event_c&lt; TagV, <I>adopted ArgT0 - ArgTm types</I> &gt; make_event(ArgT0 <span class=keyword>const</span>&amp; arg0, <I>...</I>, ArgT<I>m</I> <span class=keyword>const</span>&amp; arg<I>m</I>);
</PRE></blockquote>
</P>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/event.hpp&gt;</code><br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="instantiation_types">Instantiation types</a></h4>

<P>
<ul>
  <li><code>TagT</code> or <code>TagV</code>. A tag type or value to differentiate <code>event</code> and <code>event_c</code>
  types with the same set of parameters.</li>
  <li><code>T0</code> - <code>T<i>n</i></code>. Event argument types. The number of these types is limited with macro
  <code>BOOST_FSM_MAX_EVENT_ARGS</code>. This macro defaults to 10 and may be redefined by user, though it should not exceed
  the maximum number of <code>boost::tuple</code> template parameters.</li>
</ul>
</P>

<h4><a name="types">Types</a></h4>

<P>
<ul>
  <li><code>tag_type</code>. This type reflects the <code>TagT</code> template parameter.</li>
  <li><code>tuple_type</code>. The type of <code>boost::tuple</code> instance used to hold the event's arguments. Its template parameters
    are formed based on the <code>T0</code> - <code>T<i>n</i></code> template parameters with some adoptions.
  </li>
</ul>
</P>

<h4><a name="constructors">Constructors, copy and assignment</a></h4>

<code>event();</code><br>
<code>event_c();</code>

<blockquote>
<b>Effects:</b> Default constructs the event. Event arguments are default constructed in the inherited <code>tuple</code> instance.<br>
<b>Complexity:</b> <code>O(1)</code>, not including the <code>tuple</code> instance construction complexity.<br>
<b>Exception safety:</b> Does not throw, unless the <code>tuple</code> constructor throws.<br>
</blockquote><br>

<code>explicit event(tuple_type const&amp; that);</code><br>
<code>explicit event_c(tuple_type const&amp; that);</code>

<blockquote>
<b>Effects:</b> Constructs the event with <code>that</code> arguments. The <code>that</code> argument is passed to <code>tuple</code>'s constructor.<br>
<b>Complexity:</b> <code>O(1)</code>, not including the <code>tuple</code> instance construction complexity.<br>
<b>Exception safety:</b> Does not throw, unless the <code>tuple</code> constructor throws.<br>
</blockquote><br>

<code>event&amp; operator= (event const&amp; that);</code><br>
<code>template&lt; typename U &gt; event&amp; operator= (U const&amp; that);</code><br>
<code>event_c&amp; operator= (event_c const&amp; that);</code><br>
<code>template&lt; typename U &gt; event_c&amp; operator= (U const&amp; that);</code>

<blockquote>
<b>Effects:</b> Passes the <code>that</code> argument to <code>tuple</code>'s assignment operator.<br>
<b>Returns:</b> <code>*this</code><br>
<b>Complexity:</b> <code>O(1)</code>, not including the <code>tuple</code> assignment operator.<br>
<b>Exception safety:</b> Does not throw, unless the <code>tuple</code> operator throws.<br>
</blockquote>


<h4><a name="accessors">Accessors</a></h4>

<code>tuple_type&amp; get_tuple();</code><br>
<code>tuple_type const&amp; get_tuple() const;</code>

<blockquote>
<b>Returns:</b> <code>*this</code>.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="helpers">Helper functions</a></h4>

<code>template&lt; typename TagT, typename ArgT0, <I>...</I>, typename ArgT<I>m</I> &gt;<br>
event&lt; TagT, <I>adopted ArgT0 - ArgTm types</I> &gt; make_event(ArgT0 const&amp; arg0, <I>...</I>, ArgT<I>m</I> const&amp; arg<I>m</I>);</code><br>
<code>template&lt; int TagV, typename ArgT0, <I>...</I>, typename ArgT<I>m</I> &gt;<br>
event_c&lt; TagV, <I>adopted ArgT0 - ArgTm types</I> &gt; make_event(ArgT0 const&amp; arg0, <I>...</I>, ArgT<I>m</I> const&amp; arg<I>m</I>);</code>

<blockquote>
<b>Returns:</b> A constructed event object with <code>arg0</code> - <code>arg<i>m</i></code> arguments. If <code>ArgT<i>i</i></code>
type is a <code>boost::reference_wrapper</code> instance it is converted to a corresponding reference type to instantiate <code>event</code> or <code>event_c</code>.
This is done to simplify the event usage in the <code>on_process</code> handlers.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw, unless the <code>event</code>'s constructor throws.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class fsm_error">Class <CODE>fsm_error</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>class</span> fsm_error :
  <span class=keyword>public</span> std::exception
{
<span class=keyword>public</span>:
  <span class=comment>// Constructors</span>
  fsm_error(std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);
  fsm_error(std::string <span class=keyword>const</span>&amp; StateName, std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);

  <span class=comment>// Destructor</span>
  ~fsm_error() <span class=keyword>throw</span>();

  <span class=comment>// Public methods</span>
  std::type_info <span class=keyword>const</span>&amp; current_state_type() <span class=keyword>const</span>;
  state_id_t current_state_id() <span class=keyword>const</span>;

  <span class=keyword>const char</span>* what() <span class=keyword>const throw</span>();
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/exceptions.hpp&gt;</code>, automatically included in <code>boost/fsm/state_machine.hpp</code>.<br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="constructors">Constructors, copy, destructors and assignment</a></h4>

<code>fsm_error(std::type_info const&amp; State, state_id_t StateID);</code><br>
<code>fsm_error(std::string const&amp; StateName, std::type_info const&amp; State, state_id_t StateID);</code>

<blockquote>
<b>Effects:</b> Constructs the exception object. The arguments are saved in the exception object.<br>
<b>Complexity:</b> Arguments <code>StateName</code> and <code>StateID</code> are copied, a reference to <code>State</code> is bound
in the exception object.<br>
<b>Exception safety:</b> Does not throw, unless the <code>std::string</code> copy constructor throws.<br>
</blockquote><br>

<code>~fsm_error() throw();</code>

<blockquote>
<b>Effects:</b> Destroys the exception object.<br>
<b>Complexity:</b> May involve <code>std::string</code> objects destruction, if they were constructed through the object's lifetime.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="accessors">Accessors</a></h4>

<code>std::type_info const&amp; current_state_type() const;</code>

<blockquote>
<b>Returns:</b> The result value equals to the <code>State</code> argument of the <code>fsm_error</code> constructor. It is a type information
of the final state in which the error have occured.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>state_id_t current_state_id() const;</code>

<blockquote>
<b>Returns:</b> The result value equals to the <code>StateID</code> argument of the <code>fsm_error</code> constructor. It is an identifier
of the final state in which the error have occured.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>const char* what() const throw();</code>

<blockquote>
<b>Returns:</b> The error description.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class bad_state_id">Class <CODE>bad_state_id</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>class</span> bad_state_id :
  <span class=keyword>public</span> fsm_error
{
<span class=keyword>public</span>:
  <span class=comment>// Constructors</span>
  bad_state_id(state_id_t BadStateID, std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);
  bad_state_id(
    state_id_t BadStateID, std::string <span class=keyword>const</span>&amp; StateName, std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);

  <span class=comment>// Destructor</span>
  ~bad_state_id() <span class=keyword>throw</span>();

  <span class=comment>// Public methods</span>
  state_id_t state_id() <span class=keyword>const</span>;

  <span class=keyword>const char</span>* what() <span class=keyword>const throw</span>();
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/exceptions.hpp&gt;</code>, automatically included in <code>boost/fsm/state_machine.hpp</code>.<br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="constructors">Constructors, copy, destructors and assignment</a></h4>

<code>bad_state_id(state_id_t BadStateID, std::type_info const&amp; State, state_id_t StateID);</code><br>
<code>bad_state_id(state_id_t BadStateID, std::string const&amp; StateName, std::type_info const&amp; State, state_id_t StateID);</code>

<blockquote>
<b>Effects:</b> Constructs the exception object. The arguments are saved in the exception object.<br>
<b>Complexity:</b> Arguments <code>BadStateID</code>, <code>StateName</code> and <code>StateID</code> are copied, a reference to
<code>State</code> is bound in the exception object.<br>
<b>Exception safety:</b> Does not throw, unless the <code>std::string</code> copy constructor throws.<br>
</blockquote><br>

<code>~bad_state_id() throw();</code>

<blockquote>
<b>Effects:</b> Destroys the exception object.<br>
<b>Complexity:</b> May involve <code>std::string</code> objects destruction, if they were constructed through the object's lifetime.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="accessors">Accessors</a></h4>

<code>state_id_t state_id() const;</code>

<blockquote>
<b>Returns:</b> The result value equals to the <code>BadStateID</code> argument of the <code>bad_state_id</code> constructor. It is an invalid
state identifier that caused the exception.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>const char* what() const throw();</code>

<blockquote>
<b>Returns:</b> The error description.<br>
<b>Complexity:</b> May involve memory allocations while constructing the error message text.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<P><BR></P>

<H3><A NAME="Class unexpected_event">Class <CODE>unexpected_event</CODE></A></H3>
<P><B>Synopsis:</B>
</P><blockquote><PRE><span class=keyword>class</span> unexpected_event :
  <span class=keyword>public</span> fsm_error
{
<span class=keyword>public</span>:
  <span class=comment>// Constructors</span>
  unexpected_event(any <span class=keyword>const</span>&amp; Event, std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);
  unexpected_event(
    any <span class=keyword>const</span>&amp; Event, std::string <span class=keyword>const</span>&amp; StateName, std::type_info <span class=keyword>const</span>&amp; State, state_id_t StateID);

  <span class=comment>// Destructor</span>
  ~unexpected_event() <span class=keyword>throw</span>();

  <span class=comment>// Public methods</span>
  any <span class=keyword>const</span>&amp; event() <span class=keyword>const</span>;

  <span class=keyword>const char</span>* what() <span class=keyword>const throw</span>();
};</PRE></blockquote>

<h4><a name="location">Location</a></h4>

<code>#include &lt;boost/fsm/exceptions.hpp&gt;</code>, automatically included in <code>boost/fsm/state_machine.hpp</code>.<br>
The class is located in <code>boost::fsm</code> namespace.

<h4><a name="constructors">Constructors, copy, destructors and assignment</a></h4>

<code>unexpected_event(any const&amp; Event, std::type_info const&amp; State, state_id_t StateID);</code><br>
<code>unexpected_event(any const&amp; Event, std::string const&amp; StateName, std::type_info const&amp; State, state_id_t StateID);</code>

<blockquote>
<b>Effects:</b> Constructs the exception object. The arguments are saved in the exception object.<br>
<b>Complexity:</b> Arguments <code>Event</code>, <code>StateName</code> and <code>StateID</code> are copied, a reference to
<code>State</code> is bound in the exception object.<br>
<b>Exception safety:</b> Does not throw, unless the <code>std::string</code> or <code>boost::any</code> copy constructor throws.<br>
</blockquote><br>

<code>~unexpected_event() throw();</code>

<blockquote>
<b>Effects:</b> Destroys the exception object.<br>
<b>Complexity:</b> Implies <code>boost::any</code> destruction. May involve <code>std::string</code> objects destruction, if they were
constructed through the object's lifetime.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>

<h4><a name="accessors">Accessors</a></h4>

<code>any const&amp; event() const;</code>

<blockquote>
<b>Returns:</b> The result value is a copy of the event object that failed to be dispatched to an <code>on_process</code> handler.<br>
<b>Complexity:</b> <code>O(1)</code>.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote><br>

<code>const char* what() const throw();</code>

<blockquote>
<b>Returns:</b> The error description.<br>
<b>Complexity:</b> May involve memory allocations while constructing the error message text.<br>
<b>Exception safety:</b> Does not throw.<br>
</blockquote>


<HR>

<p class="copyright">Copyright &copy; 2006 Semashev Andrey<br></p>
<p><font size="2">Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) </font> </p>

</BODY>
</HTML>
